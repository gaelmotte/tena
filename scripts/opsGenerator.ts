import * as fs from "fs/promises";
import * as path from "path";

const OUTPUT_PATH = path.join(__dirname, "..", "src", "ops.ts");
const INPUT_PATH = path.join(__dirname, "..", "res", "ops.json");

type InstructionEntry = {
  bytes: "1" | "2" | "3";
  description: string;
  name: string;
  opcode: string;
  mode: string;
  opcodebyte?: number;
};

type OpsJson = InstructionEntry[];

const groupBy = <T>(keyFn: (x: T) => string, arr: T[]): Record<string, T[]> => {
  const out: Record<string, T[]> = {};

  arr.forEach((x) => {
    const key = keyFn(x);
    if (!(key in out)) {
      out[key] = [];
    }
    out[key].push(x);
  });

  return out;
};

const typeImports = [
  "import {",
  "  OpDescription,",
  "  Immediate,",
  "  Absolute,",
  "  ZeroPage,",
  "  Indirect,",
  "  SymbolOr,",
	"  SymbolicLabel,",
  '} from "./types";',
  "",
].join("\n");

const fns = [
  "const isSymbolRef = (x: string) => [",
  '  "symbolicLabel",',
  '  "sizeOfReference",',
  '  "relativeToReference",',
  "].includes(x);",
  "",
].join("\n");

const autogenMessage = [
  `// =============================================================================`,
  `// TEGN: TypeScript Embedded NES Macro Assembler`,
  `//`,
  `// This file is autogenerated - do not edit by hand.`,
  `// Instead edit ${path.basename(__filename)} and run "npm run generate"`,
  `// =============================================================================`,
  "",
].join("\n");

const getParams = (op: InstructionEntry) => {
  switch (op.mode) {
    case "Immediate":
      return `value: Immediate`;
    case "ZeroPage":
      return `value: SymbolOr<ZeroPage>`;
    case "Absolute":
      return `value: SymbolOr<Absolute>`;
    case "ZeroPage,X":
      return `value: SymbolOr<ZeroPage>, index: "x"`;
    case "ZeroPage,Y":
      return `value: SymbolOr<ZeroPage>, index: "y"`;
    case "Absolute,X":
      return `value: SymbolOr<Absolute>, index: "x"`;
    case "Absolute,Y":
      return `value: SymbolOr<Absolute>, index: "y"`;
    case "(Indirect,X)":
      return `value: SymbolOr<Indirect>, index: "prex"`;
    case "(Indirect),Y":
      return `value: SymbolOr<Indirect>, index: "posty"`;
    case "Implied":
      return ``;
    case "Accumulator":
      return ``;
    case "Indirect":
      return `value: SymbolOr<Indirect>`;
    case "Relative":
			return `value: SymbolicLabel`;

    default:
      return `/*TODO ${op.mode}*/`;
  }
};
const getSignature = (op: InstructionEntry) => {
  return [
    `/** ${op.description} MODE ${op.mode} */`,
    `export function ${op.name}(${getParams(op)}): OpDescription;`,
  ].join("\n");
};

const getimplementationByAdressingMode = (op: InstructionEntry) => {
  switch (op.mode) {
    case "Immediate":
      return [
        `  if(arguments.length === 1 && a1.type === "Immediate")`,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, a1.value])} as OpDescription`,
      ].join("\n");
    case "ZeroPage":
      return [
        `  if(arguments.length === 1 && a1.type === "ZeroPage") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, a1.value])} as OpDescription`,
        `  if(arguments.length === 1 && a1.type === "SymbolicLabel") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, 0]), symbol: a1, size:8, isRelative: false} as OpDescription`,
      ].join("\n");
    case "Absolute":
      return [
        `  if(arguments.length === 1 && a1.type === "Absolute") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, a1.value & 0xff, a1.value >> 8])} as OpDescription`,
        `  if(arguments.length === 1 && a1.type === "SymbolicLabel") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription`,
      ].join("\n");
    case "ZeroPage,X":
      return [
        `  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "x") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, a1.value])} as OpDescription`,
        ` if(arguments.length === 2 && a1.type === "SymbolicLabel"  && a2 === "x") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, 0]), symbol: a1, size:8, isRelative: false} as OpDescription`,
      ].join("\n");
    case "ZeroPage,Y":
      return [
        `  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "y") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, a1.value])} as OpDescription`,
        `  if(arguments.length === 2 && a1.type === "SymbolicLabel" && a2 === "y") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, 0]), symbol: a1, size:8, isRelative: false} as OpDescription`,
      ].join("\n");
    case "Absolute,X":
      return [
        `  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "x") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, a1.value & 0xff, a1.value >> 8])} as OpDescription`,
        `  if(arguments.length === 2 && a1.type === "SymbolicLabel" && a2 === "x") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription`,
      ].join("\n");
    case "Absolute,Y":
      return [
        `  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "y") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, a1.value & 0xff, a1.value >> 8])} as OpDescription`,
        `  if(arguments.length === 2 && a1.type === "SymbolicLabel"  && a2 === "y") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription`,
      ].join("\n");
    case "(Indirect,X)":
      return [
        `  if(arguments.length === 2 && a1.type === "Indirect" && a2 === "prex") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, a1.value])} as OpDescription`,
        `  if(arguments.length === 2 && a1.type === "SymbolicLabel" && a2 === "prex") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, 0]), symbol: a1, size:8, isRelative: false} as OpDescription`,
      ].join("\n");
    case "(Indirect),Y":
      return [
        `  if(arguments.length === 2 && a1.type === "Indirect" && a2 === "posty") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, a1.value])} as OpDescription`,
        `  if(arguments.length === 2 && a1.type === "SymbolicLabel" && a2 === "posty") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, 0]), symbol: a1, size:8, isRelative: false} as OpDescription`,
      ].join("\n");
    case "Implied":
      return [
        `  if(arguments.length === 0) `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}])} as OpDescription`,
      ].join("\n");
    case "Accumulator":
      return [
        `  if(arguments.length === 0) `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}])} as OpDescription`,
      ].join("\n");
    case "Indirect":
      return [
        `  if(arguments.length === 1 && a1.type === "Indirect") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, a1.value])} as OpDescription`,
        `  if(arguments.length === 1 && a1.type === "SymbolicLabel") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, 0]), symbol: a1, size:8, isRelative: false} as OpDescription`,
      ].join("\n");
    case "Relative":
      return [
        `  if(arguments.length === 1 && a1.type === "SymbolicLabel") `,
        `    return {type: "opDescription", bytes : new Uint8Array([${op.opcodebyte}, 0]), symbol: a1, size:8, isRelative: true} as OpDescription`,
      ].join("\n");

    default:
      return [`/*TODO ${op.mode}*/`];
  }
};

const getImplementation = (ops: InstructionEntry[]) => {
  return [
    `export function ${ops[0].name}(a1?: any, a2?:any): OpDescription{`,
    ...ops.map((op) => getimplementationByAdressingMode(op)),
    `throw new Error("not Implemented")`,
    `}`,
  ].join("\n");
};

const main = async () => {
  const ops: OpsJson = JSON.parse(
    await fs.readFile(INPUT_PATH, { encoding: "utf-8" })
  );

  ops.forEach((op) => {
    op.opcodebyte = parseInt(op.opcode.substring(1), 16);
  });

  const grouped = groupBy((op: InstructionEntry) => op.name, ops);
  let generated = "";
  for (let instruction in grouped) {
    generated += "\n// " + instruction + "\n";
    generated +=
      grouped[instruction]
        .map((op: InstructionEntry) => {
          return getSignature(op);
        })
        .join("\n") + "\n";
    generated += getImplementation(grouped[instruction]);
  }

  const file = [autogenMessage, typeImports, generated].join("\n");

  return fs.writeFile(OUTPUT_PATH, file);
};

main();
