// =============================================================================
// TEGN: TypeScript Embedded NES Macro Assembler
//
// This file is autogenerated - do not edit by hand.
// Instead edit opsGenerator.ts and run "npm run generate"
// =============================================================================

import {
  OpDescription,
  Immediate,
  Absolute,
  ZeroPage,
  Indirect,
  SymbolOr,
  SymbolicLabel,
} from "./types";


// ADC
/** Add with Carry MODE Immediate */
export function ADC(value: Immediate): OpDescription;
/** Add with Carry MODE ZeroPage */
export function ADC(value: SymbolOr<ZeroPage>): OpDescription;
/** Add with Carry MODE ZeroPage,X */
export function ADC(value: SymbolOr<ZeroPage>, index: "x"): OpDescription;
/** Add with Carry MODE Absolute */
export function ADC(value: SymbolOr<Absolute>): OpDescription;
/** Add with Carry MODE Absolute,X */
export function ADC(value: SymbolOr<Absolute>, index: "x"): OpDescription;
/** Add with Carry MODE Absolute,Y */
export function ADC(value: SymbolOr<Absolute>, index: "y"): OpDescription;
/** Add with Carry MODE (Indirect,X) */
export function ADC(value: SymbolOr<Indirect>, index: "prex"): OpDescription;
/** Add with Carry MODE (Indirect),Y */
export function ADC(value: SymbolOr<Indirect>, index: "posty"): OpDescription;
export function ADC(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "Immediate")
    return {type: "opDescription", bytes : new Uint8Array([105, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([101, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([101, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([117, a1.value])} as OpDescription
 if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([117, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([109, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([125, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([125, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "y") 
    return {type: "opDescription", bytes : new Uint8Array([121, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([121, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Indirect" && a2 === "prex") 
    return {type: "opDescription", bytes : new Uint8Array([97, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([97, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Indirect" && a2 === "posty") 
    return {type: "opDescription", bytes : new Uint8Array([113, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([113, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
throw new Error("not Implemented")
}
// AND
/** Logical AND MODE Immediate */
export function AND(value: Immediate): OpDescription;
/** Logical AND MODE ZeroPage */
export function AND(value: SymbolOr<ZeroPage>): OpDescription;
/** Logical AND MODE ZeroPage,X */
export function AND(value: SymbolOr<ZeroPage>, index: "x"): OpDescription;
/** Logical AND MODE Absolute */
export function AND(value: SymbolOr<Absolute>): OpDescription;
/** Logical AND MODE Absolute,X */
export function AND(value: SymbolOr<Absolute>, index: "x"): OpDescription;
/** Logical AND MODE Absolute,Y */
export function AND(value: SymbolOr<Absolute>, index: "y"): OpDescription;
/** Logical AND MODE (Indirect,X) */
export function AND(value: SymbolOr<Indirect>, index: "prex"): OpDescription;
/** Logical AND MODE (Indirect),Y */
export function AND(value: SymbolOr<Indirect>, index: "posty"): OpDescription;
export function AND(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "Immediate")
    return {type: "opDescription", bytes : new Uint8Array([41, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([37, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([37, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([53, a1.value])} as OpDescription
 if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([53, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([45, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([61, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([61, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "y") 
    return {type: "opDescription", bytes : new Uint8Array([57, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([57, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Indirect" && a2 === "prex") 
    return {type: "opDescription", bytes : new Uint8Array([33, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([33, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Indirect" && a2 === "posty") 
    return {type: "opDescription", bytes : new Uint8Array([49, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([49, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
throw new Error("not Implemented")
}
// ASL
/** Arithmetic Shift Left MODE Accumulator */
export function ASL(): OpDescription;
/** Arithmetic Shift Left MODE ZeroPage */
export function ASL(value: SymbolOr<ZeroPage>): OpDescription;
/** Arithmetic Shift Left MODE ZeroPage,X */
export function ASL(value: SymbolOr<ZeroPage>, index: "x"): OpDescription;
/** Arithmetic Shift Left MODE Absolute */
export function ASL(value: SymbolOr<Absolute>): OpDescription;
/** Arithmetic Shift Left MODE Absolute,X */
export function ASL(value: SymbolOr<Absolute>, index: "x"): OpDescription;
export function ASL(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([10])} as OpDescription
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([6, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([6, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([22, a1.value])} as OpDescription
 if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([22, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([14, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([30, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([30, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
throw new Error("not Implemented")
}
// BCC
/** Branch if Carry Clear MODE Relative */
export function BCC(value: SymbolicLabel): OpDescription;
export function BCC(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([144, 0]), symbol: a1, size:8, isRelative: true} as OpDescription
throw new Error("not Implemented")
}
// BCS
/** Branch if Carry Set MODE Relative */
export function BCS(value: SymbolicLabel): OpDescription;
export function BCS(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([176, 0]), symbol: a1, size:8, isRelative: true} as OpDescription
throw new Error("not Implemented")
}
// BEQ
/** Branch if Equal MODE Relative */
export function BEQ(value: SymbolicLabel): OpDescription;
export function BEQ(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([240, 0]), symbol: a1, size:8, isRelative: true} as OpDescription
throw new Error("not Implemented")
}
// BIT
/** Bit Test MODE ZeroPage */
export function BIT(value: SymbolOr<ZeroPage>): OpDescription;
/** Bit Test MODE Absolute */
export function BIT(value: SymbolOr<Absolute>): OpDescription;
export function BIT(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([36, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([36, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([44, a1.value & 0xff, a1.value >> 8])} as OpDescription
throw new Error("not Implemented")
}
// BMI
/** Branch if Minus MODE Relative */
export function BMI(value: SymbolicLabel): OpDescription;
export function BMI(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([48, 0]), symbol: a1, size:8, isRelative: true} as OpDescription
throw new Error("not Implemented")
}
// BNE
/** Branch if Not Equal MODE Relative */
export function BNE(value: SymbolicLabel): OpDescription;
export function BNE(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([208, 0]), symbol: a1, size:8, isRelative: true} as OpDescription
throw new Error("not Implemented")
}
// BPL
/** Branch if Positive MODE Relative */
export function BPL(value: SymbolicLabel): OpDescription;
export function BPL(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([16, 0]), symbol: a1, size:8, isRelative: true} as OpDescription
throw new Error("not Implemented")
}
// BRK
/** Force Interrupt MODE Implied */
export function BRK(): OpDescription;
export function BRK(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([0])} as OpDescription
throw new Error("not Implemented")
}
// BVC
/** Branch if Overflow Clear MODE Relative */
export function BVC(value: SymbolicLabel): OpDescription;
export function BVC(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([80, 0]), symbol: a1, size:8, isRelative: true} as OpDescription
throw new Error("not Implemented")
}
// BVS
/** Branch if Overflow Set MODE Relative */
export function BVS(value: SymbolicLabel): OpDescription;
export function BVS(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([112, 0]), symbol: a1, size:8, isRelative: true} as OpDescription
throw new Error("not Implemented")
}
// CLC
/** Clear Carry Flag MODE Implied */
export function CLC(): OpDescription;
export function CLC(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([24])} as OpDescription
throw new Error("not Implemented")
}
// CLD
/** Clear Decimal Mode MODE Implied */
export function CLD(): OpDescription;
export function CLD(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([216])} as OpDescription
throw new Error("not Implemented")
}
// CLI
/** Clear Interrupt Disable MODE Implied */
export function CLI(): OpDescription;
export function CLI(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([88])} as OpDescription
throw new Error("not Implemented")
}
// CLV
/** Clear Overflow Flag MODE Implied */
export function CLV(): OpDescription;
export function CLV(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([184])} as OpDescription
throw new Error("not Implemented")
}
// CMP
/** Compare MODE Immediate */
export function CMP(value: Immediate): OpDescription;
/** Compare MODE ZeroPage */
export function CMP(value: SymbolOr<ZeroPage>): OpDescription;
/** Compare MODE ZeroPage,X */
export function CMP(value: SymbolOr<ZeroPage>, index: "x"): OpDescription;
/** Compare MODE Absolute */
export function CMP(value: SymbolOr<Absolute>): OpDescription;
/** Compare MODE Absolute,X */
export function CMP(value: SymbolOr<Absolute>, index: "x"): OpDescription;
/** Compare MODE Absolute,Y */
export function CMP(value: SymbolOr<Absolute>, index: "y"): OpDescription;
/** Compare MODE (Indirect,X) */
export function CMP(value: SymbolOr<Indirect>, index: "prex"): OpDescription;
/** Compare MODE (Indirect),Y */
export function CMP(value: SymbolOr<Indirect>, index: "posty"): OpDescription;
export function CMP(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "Immediate")
    return {type: "opDescription", bytes : new Uint8Array([201, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([197, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([197, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([213, a1.value])} as OpDescription
 if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([213, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([205, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([221, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([221, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "y") 
    return {type: "opDescription", bytes : new Uint8Array([217, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([217, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Indirect" && a2 === "prex") 
    return {type: "opDescription", bytes : new Uint8Array([193, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([193, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Indirect" && a2 === "posty") 
    return {type: "opDescription", bytes : new Uint8Array([209, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([209, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
throw new Error("not Implemented")
}
// CPX
/** Compare X Register MODE Immediate */
export function CPX(value: Immediate): OpDescription;
/** Compare X Register MODE ZeroPage */
export function CPX(value: SymbolOr<ZeroPage>): OpDescription;
/** Compare X Register MODE Absolute */
export function CPX(value: SymbolOr<Absolute>): OpDescription;
export function CPX(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "Immediate")
    return {type: "opDescription", bytes : new Uint8Array([224, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([228, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([228, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([236, a1.value & 0xff, a1.value >> 8])} as OpDescription
throw new Error("not Implemented")
}
// CPY
/** Compare Y Register MODE Immediate */
export function CPY(value: Immediate): OpDescription;
/** Compare Y Register MODE ZeroPage */
export function CPY(value: SymbolOr<ZeroPage>): OpDescription;
/** Compare Y Register MODE Absolute */
export function CPY(value: SymbolOr<Absolute>): OpDescription;
export function CPY(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "Immediate")
    return {type: "opDescription", bytes : new Uint8Array([192, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([196, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([196, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([204, a1.value & 0xff, a1.value >> 8])} as OpDescription
throw new Error("not Implemented")
}
// DEC
/** Decrement Memory MODE ZeroPage */
export function DEC(value: SymbolOr<ZeroPage>): OpDescription;
/** Decrement Memory MODE ZeroPage,X */
export function DEC(value: SymbolOr<ZeroPage>, index: "x"): OpDescription;
/** Decrement Memory MODE Absolute */
export function DEC(value: SymbolOr<Absolute>): OpDescription;
/** Decrement Memory MODE Absolute,X */
export function DEC(value: SymbolOr<Absolute>, index: "x"): OpDescription;
export function DEC(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([198, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([198, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([214, a1.value])} as OpDescription
 if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([214, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([206, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([222, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([222, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
throw new Error("not Implemented")
}
// DEX
/** Decrement X Register MODE Implied */
export function DEX(): OpDescription;
export function DEX(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([202])} as OpDescription
throw new Error("not Implemented")
}
// DEY
/** Decrement Y Register MODE Implied */
export function DEY(): OpDescription;
export function DEY(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([136])} as OpDescription
throw new Error("not Implemented")
}
// EOR
/** Exclusive OR MODE Immediate */
export function EOR(value: Immediate): OpDescription;
/** Exclusive OR MODE ZeroPage */
export function EOR(value: SymbolOr<ZeroPage>): OpDescription;
/** Exclusive OR MODE ZeroPage,X */
export function EOR(value: SymbolOr<ZeroPage>, index: "x"): OpDescription;
/** Exclusive OR MODE Absolute */
export function EOR(value: SymbolOr<Absolute>): OpDescription;
/** Exclusive OR MODE Absolute,X */
export function EOR(value: SymbolOr<Absolute>, index: "x"): OpDescription;
/** Exclusive OR MODE Absolute,Y */
export function EOR(value: SymbolOr<Absolute>, index: "y"): OpDescription;
/** Exclusive OR MODE (Indirect,X) */
export function EOR(value: SymbolOr<Indirect>, index: "prex"): OpDescription;
/** Exclusive OR MODE (Indirect),Y */
export function EOR(value: SymbolOr<Indirect>, index: "posty"): OpDescription;
export function EOR(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "Immediate")
    return {type: "opDescription", bytes : new Uint8Array([73, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([69, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([69, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([85, a1.value])} as OpDescription
 if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([85, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([77, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([93, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([93, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "y") 
    return {type: "opDescription", bytes : new Uint8Array([89, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([89, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Indirect" && a2 === "prex") 
    return {type: "opDescription", bytes : new Uint8Array([65, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([65, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Indirect" && a2 === "posty") 
    return {type: "opDescription", bytes : new Uint8Array([81, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([81, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
throw new Error("not Implemented")
}
// INC
/** Increment Memory MODE ZeroPage */
export function INC(value: SymbolOr<ZeroPage>): OpDescription;
/** Increment Memory MODE ZeroPage,X */
export function INC(value: SymbolOr<ZeroPage>, index: "x"): OpDescription;
/** Increment Memory MODE Absolute */
export function INC(value: SymbolOr<Absolute>): OpDescription;
/** Increment Memory MODE Absolute,X */
export function INC(value: SymbolOr<Absolute>, index: "x"): OpDescription;
export function INC(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([230, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([230, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([246, a1.value])} as OpDescription
 if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([246, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([238, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([254, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([254, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
throw new Error("not Implemented")
}
// INX
/** Increment X Register MODE Implied */
export function INX(): OpDescription;
export function INX(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([232])} as OpDescription
throw new Error("not Implemented")
}
// INY
/** Increment Y Register MODE Implied */
export function INY(): OpDescription;
export function INY(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([200])} as OpDescription
throw new Error("not Implemented")
}
// JMP
/** Jump MODE Absolute */
export function JMP(value: SymbolOr<Absolute>): OpDescription;
/** Jump MODE Indirect */
export function JMP(value: SymbolOr<Indirect>): OpDescription;
export function JMP(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([76, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "Indirect") 
    return {type: "opDescription", bytes : new Uint8Array([108, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([108, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
throw new Error("not Implemented")
}
// JSR
/** Jump to Subroutine MODE Absolute */
export function JSR(value: SymbolOr<Absolute>): OpDescription;
export function JSR(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([32, a1.value & 0xff, a1.value >> 8])} as OpDescription
throw new Error("not Implemented")
}
// LDA
/** Load Accumulator MODE Immediate */
export function LDA(value: Immediate): OpDescription;
/** Load Accumulator MODE ZeroPage */
export function LDA(value: SymbolOr<ZeroPage>): OpDescription;
/** Load Accumulator MODE ZeroPage,X */
export function LDA(value: SymbolOr<ZeroPage>, index: "x"): OpDescription;
/** Load Accumulator MODE Absolute */
export function LDA(value: SymbolOr<Absolute>): OpDescription;
/** Load Accumulator MODE Absolute,X */
export function LDA(value: SymbolOr<Absolute>, index: "x"): OpDescription;
/** Load Accumulator MODE Absolute,Y */
export function LDA(value: SymbolOr<Absolute>, index: "y"): OpDescription;
/** Load Accumulator MODE (Indirect,X) */
export function LDA(value: SymbolOr<Indirect>, index: "prex"): OpDescription;
/** Load Accumulator MODE (Indirect),Y */
export function LDA(value: SymbolOr<Indirect>, index: "posty"): OpDescription;
export function LDA(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "Immediate")
    return {type: "opDescription", bytes : new Uint8Array([169, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([165, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([165, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([181, a1.value])} as OpDescription
 if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([181, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([173, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([189, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([189, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "y") 
    return {type: "opDescription", bytes : new Uint8Array([185, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([185, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Indirect" && a2 === "prex") 
    return {type: "opDescription", bytes : new Uint8Array([161, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([161, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Indirect" && a2 === "posty") 
    return {type: "opDescription", bytes : new Uint8Array([177, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([177, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
throw new Error("not Implemented")
}
// LDX
/** Load X Register MODE Immediate */
export function LDX(value: Immediate): OpDescription;
/** Load X Register MODE ZeroPage */
export function LDX(value: SymbolOr<ZeroPage>): OpDescription;
/** Load X Register MODE ZeroPage,Y */
export function LDX(value: SymbolOr<ZeroPage>, index: "y"): OpDescription;
/** Load X Register MODE Absolute */
export function LDX(value: SymbolOr<Absolute>): OpDescription;
/** Load X Register MODE Absolute,Y */
export function LDX(value: SymbolOr<Absolute>, index: "y"): OpDescription;
export function LDX(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "Immediate")
    return {type: "opDescription", bytes : new Uint8Array([162, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([166, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([166, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "y") 
    return {type: "opDescription", bytes : new Uint8Array([182, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([182, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([174, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "y") 
    return {type: "opDescription", bytes : new Uint8Array([190, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([190, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
throw new Error("not Implemented")
}
// LDY
/** Load Y Register MODE Immediate */
export function LDY(value: Immediate): OpDescription;
/** Load Y Register MODE ZeroPage */
export function LDY(value: SymbolOr<ZeroPage>): OpDescription;
/** Load Y Register MODE ZeroPage,X */
export function LDY(value: SymbolOr<ZeroPage>, index: "x"): OpDescription;
/** Load Y Register MODE Absolute */
export function LDY(value: SymbolOr<Absolute>): OpDescription;
/** Load Y Register MODE Absolute,X */
export function LDY(value: SymbolOr<Absolute>, index: "x"): OpDescription;
export function LDY(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "Immediate")
    return {type: "opDescription", bytes : new Uint8Array([160, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([164, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([164, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([180, a1.value])} as OpDescription
 if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([180, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([172, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([188, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([188, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
throw new Error("not Implemented")
}
// LSR
/** Logical Shift Right MODE Accumulator */
export function LSR(): OpDescription;
/** Logical Shift Right MODE ZeroPage */
export function LSR(value: SymbolOr<ZeroPage>): OpDescription;
/** Logical Shift Right MODE ZeroPage,X */
export function LSR(value: SymbolOr<ZeroPage>, index: "x"): OpDescription;
/** Logical Shift Right MODE Absolute */
export function LSR(value: SymbolOr<Absolute>): OpDescription;
/** Logical Shift Right MODE Absolute,X */
export function LSR(value: SymbolOr<Absolute>, index: "x"): OpDescription;
export function LSR(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([74])} as OpDescription
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([70, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([70, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([86, a1.value])} as OpDescription
 if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([86, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([78, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([94, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([94, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
throw new Error("not Implemented")
}
// NOP
/** No Operation MODE Implied */
export function NOP(): OpDescription;
export function NOP(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([234])} as OpDescription
throw new Error("not Implemented")
}
// ORA
/** Logical Inclusive OR MODE Immediate */
export function ORA(value: Immediate): OpDescription;
/** Logical Inclusive OR MODE ZeroPage */
export function ORA(value: SymbolOr<ZeroPage>): OpDescription;
/** Logical Inclusive OR MODE ZeroPage,X */
export function ORA(value: SymbolOr<ZeroPage>, index: "x"): OpDescription;
/** Logical Inclusive OR MODE Absolute */
export function ORA(value: SymbolOr<Absolute>): OpDescription;
/** Logical Inclusive OR MODE Absolute,X */
export function ORA(value: SymbolOr<Absolute>, index: "x"): OpDescription;
/** Logical Inclusive OR MODE Absolute,Y */
export function ORA(value: SymbolOr<Absolute>, index: "y"): OpDescription;
/** Logical Inclusive OR MODE (Indirect,X) */
export function ORA(value: SymbolOr<Indirect>, index: "prex"): OpDescription;
/** Logical Inclusive OR MODE (Indirect),Y */
export function ORA(value: SymbolOr<Indirect>, index: "posty"): OpDescription;
export function ORA(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "Immediate")
    return {type: "opDescription", bytes : new Uint8Array([9, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([5, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([5, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([21, a1.value])} as OpDescription
 if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([21, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([13, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([29, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([29, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "y") 
    return {type: "opDescription", bytes : new Uint8Array([25, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([25, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Indirect" && a2 === "prex") 
    return {type: "opDescription", bytes : new Uint8Array([1, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([1, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Indirect" && a2 === "posty") 
    return {type: "opDescription", bytes : new Uint8Array([17, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([17, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
throw new Error("not Implemented")
}
// PHA
/** Push Accumulator MODE Implied */
export function PHA(): OpDescription;
export function PHA(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([72])} as OpDescription
throw new Error("not Implemented")
}
// PHP
/** Push Processor Status MODE Implied */
export function PHP(): OpDescription;
export function PHP(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([8])} as OpDescription
throw new Error("not Implemented")
}
// PLA
/** Pull Accumulator MODE Implied */
export function PLA(): OpDescription;
export function PLA(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([104])} as OpDescription
throw new Error("not Implemented")
}
// PLP
/** Pull Processor Status MODE Implied */
export function PLP(): OpDescription;
export function PLP(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([40])} as OpDescription
throw new Error("not Implemented")
}
// ROL
/** Rotate Left MODE Accumulator */
export function ROL(): OpDescription;
/** Rotate Left MODE ZeroPage */
export function ROL(value: SymbolOr<ZeroPage>): OpDescription;
/** Rotate Left MODE ZeroPage,X */
export function ROL(value: SymbolOr<ZeroPage>, index: "x"): OpDescription;
/** Rotate Left MODE Absolute */
export function ROL(value: SymbolOr<Absolute>): OpDescription;
/** Rotate Left MODE Absolute,X */
export function ROL(value: SymbolOr<Absolute>, index: "x"): OpDescription;
export function ROL(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([42])} as OpDescription
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([38, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([38, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([54, a1.value])} as OpDescription
 if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([54, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([46, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([62, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([62, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
throw new Error("not Implemented")
}
// ROR
/** Rotate Right MODE Accumulator */
export function ROR(): OpDescription;
/** Rotate Right MODE ZeroPage */
export function ROR(value: SymbolOr<ZeroPage>): OpDescription;
/** Rotate Right MODE ZeroPage,X */
export function ROR(value: SymbolOr<ZeroPage>, index: "x"): OpDescription;
/** Rotate Right MODE Absolute */
export function ROR(value: SymbolOr<Absolute>): OpDescription;
/** Rotate Right MODE Absolute,X */
export function ROR(value: SymbolOr<Absolute>, index: "x"): OpDescription;
export function ROR(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([106])} as OpDescription
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([102, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([102, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([118, a1.value])} as OpDescription
 if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([118, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([110, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([126, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([126, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
throw new Error("not Implemented")
}
// RTI
/** Return from Interrupt MODE Implied */
export function RTI(): OpDescription;
export function RTI(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([64])} as OpDescription
throw new Error("not Implemented")
}
// RTS
/** Return from Subroutine MODE Implied */
export function RTS(): OpDescription;
export function RTS(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([96])} as OpDescription
throw new Error("not Implemented")
}
// SBC
/** Subtract with Carry MODE Immediate */
export function SBC(value: Immediate): OpDescription;
/** Subtract with Carry MODE ZeroPage */
export function SBC(value: SymbolOr<ZeroPage>): OpDescription;
/** Subtract with Carry MODE ZeroPage,X */
export function SBC(value: SymbolOr<ZeroPage>, index: "x"): OpDescription;
/** Subtract with Carry MODE Absolute */
export function SBC(value: SymbolOr<Absolute>): OpDescription;
/** Subtract with Carry MODE Absolute,X */
export function SBC(value: SymbolOr<Absolute>, index: "x"): OpDescription;
/** Subtract with Carry MODE Absolute,Y */
export function SBC(value: SymbolOr<Absolute>, index: "y"): OpDescription;
/** Subtract with Carry MODE (Indirect,X) */
export function SBC(value: SymbolOr<Indirect>, index: "prex"): OpDescription;
/** Subtract with Carry MODE (Indirect),Y */
export function SBC(value: SymbolOr<Indirect>, index: "posty"): OpDescription;
export function SBC(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "Immediate")
    return {type: "opDescription", bytes : new Uint8Array([233, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([229, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([229, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([245, a1.value])} as OpDescription
 if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([245, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([237, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([253, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([253, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "y") 
    return {type: "opDescription", bytes : new Uint8Array([249, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([249, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Indirect" && a2 === "prex") 
    return {type: "opDescription", bytes : new Uint8Array([225, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([225, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Indirect" && a2 === "posty") 
    return {type: "opDescription", bytes : new Uint8Array([241, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([241, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
throw new Error("not Implemented")
}
// SEC
/** Set Carry Flag MODE Implied */
export function SEC(): OpDescription;
export function SEC(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([56])} as OpDescription
throw new Error("not Implemented")
}
// SED
/** Set Decimal Flag MODE Implied */
export function SED(): OpDescription;
export function SED(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([248])} as OpDescription
throw new Error("not Implemented")
}
// SEI
/** Set Interrupt Disable MODE Implied */
export function SEI(): OpDescription;
export function SEI(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([120])} as OpDescription
throw new Error("not Implemented")
}
// STA
/** Store Accumulator MODE ZeroPage */
export function STA(value: SymbolOr<ZeroPage>): OpDescription;
/** Store Accumulator MODE ZeroPage,X */
export function STA(value: SymbolOr<ZeroPage>, index: "x"): OpDescription;
/** Store Accumulator MODE Absolute */
export function STA(value: SymbolOr<Absolute>): OpDescription;
/** Store Accumulator MODE Absolute,X */
export function STA(value: SymbolOr<Absolute>, index: "x"): OpDescription;
/** Store Accumulator MODE Absolute,Y */
export function STA(value: SymbolOr<Absolute>, index: "y"): OpDescription;
/** Store Accumulator MODE (Indirect,X) */
export function STA(value: SymbolOr<Indirect>, index: "prex"): OpDescription;
/** Store Accumulator MODE (Indirect),Y */
export function STA(value: SymbolOr<Indirect>, index: "posty"): OpDescription;
export function STA(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([133, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([133, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([149, a1.value])} as OpDescription
 if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([149, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([141, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([157, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([157, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Absolute" && a2 === "y") 
    return {type: "opDescription", bytes : new Uint8Array([153, a1.value & 0xff, a1.value >> 8])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([153, 0, 0]), symbol: a1, size:16, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Indirect" && a2 === "prex") 
    return {type: "opDescription", bytes : new Uint8Array([129, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([129, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "Indirect" && a2 === "posty") 
    return {type: "opDescription", bytes : new Uint8Array([145, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([145, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
throw new Error("not Implemented")
}
// STX
/** Store X Register MODE ZeroPage */
export function STX(value: SymbolOr<ZeroPage>): OpDescription;
/** Store X Register MODE ZeroPage,Y */
export function STX(value: SymbolOr<ZeroPage>, index: "y"): OpDescription;
/** Store X Register MODE Absolute */
export function STX(value: SymbolOr<Absolute>): OpDescription;
export function STX(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([134, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([134, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "y") 
    return {type: "opDescription", bytes : new Uint8Array([150, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([150, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([142, a1.value & 0xff, a1.value >> 8])} as OpDescription
throw new Error("not Implemented")
}
// STY
/** Store Y Register MODE ZeroPage */
export function STY(value: SymbolOr<ZeroPage>): OpDescription;
/** Store Y Register MODE ZeroPage,X */
export function STY(value: SymbolOr<ZeroPage>, index: "x"): OpDescription;
/** Store Y Register MODE Absolute */
export function STY(value: SymbolOr<Absolute>): OpDescription;
export function STY(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 1 && a1.type === "ZeroPage") 
    return {type: "opDescription", bytes : new Uint8Array([132, a1.value])} as OpDescription
  if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([132, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 2 && a1.type === "ZeroPage" && a2 === "x") 
    return {type: "opDescription", bytes : new Uint8Array([148, a1.value])} as OpDescription
 if(arguments.length === 1 && a1.type === "SymbolicLabel") 
    return {type: "opDescription", bytes : new Uint8Array([148, 0]), symbol: a1, size:8, isRelative: false} as OpDescription
  if(arguments.length === 1 && a1.type === "Absolute") 
    return {type: "opDescription", bytes : new Uint8Array([140, a1.value & 0xff, a1.value >> 8])} as OpDescription
throw new Error("not Implemented")
}
// TAX
/** Transfer Accumulator to X MODE Implied */
export function TAX(): OpDescription;
export function TAX(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([170])} as OpDescription
throw new Error("not Implemented")
}
// TAY
/** Transfer Accumulator to Y MODE Implied */
export function TAY(): OpDescription;
export function TAY(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([168])} as OpDescription
throw new Error("not Implemented")
}
// TSX
/** Transfer Stack Pointer to X MODE Implied */
export function TSX(): OpDescription;
export function TSX(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([186])} as OpDescription
throw new Error("not Implemented")
}
// TXA
/** Transfer X to Accumulator MODE Implied */
export function TXA(): OpDescription;
export function TXA(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([138])} as OpDescription
throw new Error("not Implemented")
}
// TXS
/** Transfer X to Stack Pointer MODE Implied */
export function TXS(): OpDescription;
export function TXS(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([154])} as OpDescription
throw new Error("not Implemented")
}
// TYA
/** Transfer Y to Accumulator MODE Implied */
export function TYA(): OpDescription;
export function TYA(a1?: any, a2?:any): OpDescription{
  if(arguments.length === 0) 
    return {type: "opDescription", bytes : new Uint8Array([152])} as OpDescription
throw new Error("not Implemented")
}